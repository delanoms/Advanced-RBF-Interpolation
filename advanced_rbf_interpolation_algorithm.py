# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AdvancedRBFInterpolation
                                 A QGIS plugin
 Advanced RBF interpolation with neighborhood control, local interpolation, and extrapolation options for large datasets
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-06-16
        copyright            : (C) 2025 by Delano M. Santos
        email                : projetos.delano@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Delano M. Santos'
__date__ = '2025-06-16'
__copyright__ = '(C) 2025 by Delano M. Santos'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterField,
    QgsProcessingParameterEnum,
    QgsProcessingParameterNumber,
    QgsProcessingParameterExtent,
    QgsProcessingParameterRasterDestination,
    QgsProcessingParameterBoolean,
    QgsWkbTypes,
    QgsRasterLayer,
    QgsProject,
    QgsProcessingException,
    QgsProcessing
)
from .rbf_utils import interpolate_rbf_advanced
from osgeo import gdal, osr
import numpy as np
import os



class RbfInterpolationAdvancedAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Parâmetros existentes
    INPUT_LAYER = 'INPUT_LAYER'
    VALUE_FIELD = 'VALUE_FIELD'
    RBF_FUNCTION = 'RBF_FUNCTION'
    SMOOTH_PARAM = 'SMOOTH_PARAM'
    CELL_SIZE = 'CELL_SIZE'
    EXTENT = 'EXTENT'
    OUTPUT_RASTER = 'OUTPUT_RASTER'
    USE_LOCAL_INTERPOLATION = 'USE_LOCAL_INTERPOLATION'
    MAX_NEIGHBORS = 'MAX_NEIGHBORS'
    SEARCH_RADIUS = 'SEARCH_RADIUS'
    EXTRAPOLATION_METHOD = 'EXTRAPOLATION_METHOD'
    EXTRAPOLATION_VALUE = 'EXTRAPOLATION_VALUE'

    def tr(self, string):
        return QCoreApplication.translate('RbfInterpolationAdvancedAlgorithm', string)

    def name(self):
        return 'rbf_interpolation_advanced'

    def displayName(self):
        return self.tr('Interpolação RBF Avançada')

    def group(self):
        return self.tr('Interpolação')

    def groupId(self):
        return 'interpolation'

    def shortHelpString(self):
        return self.tr("""
        Realiza interpolação por Função de Base Radial (RBF) avançada com controle de vizinhança, interpolação local e opções de extrapolação.
        
        Parâmetros principais:
        - Escolha entre 7 funções RBF: thin_plate, multiquadric, inverse_multiquadric, gaussian, linear, cubic, quintic
        - Parâmetro de suavização (smooth) ajustável
        - Tamanho da célula e extensão de saída configuráveis
        - Modo local: limite de vizinhos e raio de busca para grandes datasets
        - Métodos de extrapolação: nenhum (NaN), valor constante, vizinho mais próximo, interpolação linear
        - Valor de extrapolação constante opcional
        - Saída raster georreferenciada
        
        Recomendações:
        - Para grandes volumes de dados, ative a interpolação local e ajuste vizinhos/raio.
        - Use o método de extrapolação "constante" para preencher áreas fora do convex hull.
        """)

    def createInstance(self):
        return RbfInterpolationAdvancedAlgorithm()

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_LAYER,
                self.tr('Camada de pontos de entrada'),
                [QgsProcessing.TypeVectorPoint]
            )
        )
        self.addParameter(
            QgsProcessingParameterField(
                self.VALUE_FIELD,
                self.tr('Campo de valor para interpolação'),
                parentLayerParameterName=self.INPUT_LAYER,
                type=QgsProcessingParameterField.Numeric,
                allowMultiple=False
            )
        )
        rbf_functions = [
            'thin_plate', 'multiquadric', 'inverse_multiquadric',
            'gaussian', 'linear', 'cubic', 'quintic'
        ]
        rbf_function_names = [
            self.tr('Thin Plate'),
            self.tr('Multiquadric'),
            self.tr('Inverse Multiquadric'),
            self.tr('Gaussian'),
            self.tr('Linear'),
            self.tr('Cubic'),
            self.tr('Quintic')
        ]
        self.addParameter(
            QgsProcessingParameterEnum(
                self.RBF_FUNCTION,
                self.tr('Função RBF'),
                options=rbf_function_names,
                defaultValue=rbf_functions.index('thin_plate')
            )
        )
        self.rbf_functions_map = {idx: func for idx, func in enumerate(rbf_functions)}
        self.addParameter(
            QgsProcessingParameterNumber(
                self.SMOOTH_PARAM,
                self.tr('Parâmetro de suavização (smooth)'),
                QgsProcessingParameterNumber.Double,
                defaultValue=0.1,
                minValue=0.0
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.CELL_SIZE,
                self.tr('Tamanho da célula de saída'),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.0,
                minValue=0.000001
            )
        )
        self.addParameter(
            QgsProcessingParameterExtent(
                self.EXTENT,
                self.tr('Extensão da interpolação'),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_LOCAL_INTERPOLATION,
                self.tr('Usar interpolação local'),
                defaultValue=False
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_NEIGHBORS,
                self.tr('Número máximo de pontos vizinhos'),
                QgsProcessingParameterNumber.Integer,
                defaultValue=50,
                minValue=0,
                maxValue=1000,
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.SEARCH_RADIUS,
                self.tr('Raio de busca'),
                QgsProcessingParameterNumber.Double,
                defaultValue=0.0,
                minValue=0.0,
                optional=True
            )
        )
        extrapolation_methods = ['none', 'constant', 'nearest', 'linear']
        self.addParameter(
            QgsProcessingParameterEnum(
                self.EXTRAPOLATION_METHOD,
                self.tr('Método de extrapolação'),
                options=[
                    self.tr('Nenhum (manter NaN)'),
                    self.tr('Valor constante'),
                    self.tr('Vizinho mais próximo'),
                    self.tr('Interpolação linear')
                ],
                defaultValue=extrapolation_methods.index('constant')
            )
        )
        self.extrapolation_methods_map = {idx: method for idx, method in enumerate(extrapolation_methods)}
        self.addParameter(
            QgsProcessingParameterNumber(
                self.EXTRAPOLATION_VALUE,
                self.tr('Valor para extrapolação constante'),
                QgsProcessingParameterNumber.Double,
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT_RASTER,
                self.tr('Raster interpolado')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        feedback.setProgressText(self.tr('Iniciando interpolação RBF avançada...'))
        input_layer = self.parameterAsSource(parameters, self.INPUT_LAYER, context)
        value_field_name = self.parameterAsString(parameters, self.VALUE_FIELD, context)
        rbf_function_idx = self.parameterAsEnum(parameters, self.RBF_FUNCTION, context)
        rbf_function = self.rbf_functions_map[rbf_function_idx]
        smooth_param = self.parameterAsDouble(parameters, self.SMOOTH_PARAM, context)
        cell_size = self.parameterAsDouble(parameters, self.CELL_SIZE, context)
        output_raster_path = self.parameterAsFileOutput(parameters, self.OUTPUT_RASTER, context)
        use_local = self.parameterAsBool(parameters, self.USE_LOCAL_INTERPOLATION, context)
        max_neighbors = self.parameterAsInt(parameters, self.MAX_NEIGHBORS, context)
        search_radius = self.parameterAsDouble(parameters, self.SEARCH_RADIUS, context)
        extrapolation_method_idx = self.parameterAsEnum(parameters, self.EXTRAPOLATION_METHOD, context)
        extrapolation_method = self.extrapolation_methods_map[extrapolation_method_idx]
        extrapolation_value = self.parameterAsDouble(parameters, self.EXTRAPOLATION_VALUE, context) if parameters[self.EXTRAPOLATION_VALUE] is not None else None
        if max_neighbors == 0:
            max_neighbors = None
        if search_radius == 0.0:
            search_radius = None
        if not use_local:
            max_neighbors = None
            search_radius = None
        extent = self.parameterAsExtent(parameters, self.EXTENT, context)
        if extent.isNull():
            extent = input_layer.sourceExtent()
        if input_layer is None:
            raise QgsProcessingException(self.tr('Camada de pontos de entrada inválida.'))
        if value_field_name not in input_layer.fields().names():
            raise QgsProcessingException(self.tr(f'Campo de valor "{value_field_name}" não encontrado.'))
        if cell_size <= 0:
            raise QgsProcessingException(self.tr('Tamanho da célula deve ser maior que zero.'))
        points_data = []
        values_data = []
        total_features = input_layer.featureCount()
        if total_features == 0:
            raise QgsProcessingException(self.tr('A camada de entrada não contém feições.'))
        feedback.setProgressText(self.tr('Lendo dados dos pontos...'))
        for i, feature in enumerate(input_layer.getFeatures()):
            if feedback.isCanceled():
                return {}
            geom = feature.geometry()
            if geom.type() == QgsWkbTypes.PointGeometry:
                point = geom.asPoint()
                value = feature[value_field_name]
                if value is not None:
                    try:
                        value_float = float(value)
                        if not np.isnan(value_float) and not np.isinf(value_float):
                            points_data.append([point.x(), point.y()])
                            values_data.append(value_float)
                    except (ValueError, TypeError):
                        continue
            feedback.setProgress(int((i / total_features) * 15))
        if not points_data:
            raise QgsProcessingException(self.tr('Nenhum ponto válido encontrado.'))
        points_np = np.array(points_data)
        values_np = np.array(values_data)
        feedback.pushInfo(self.tr(f"Processando {len(values_data)} pontos válidos"))
        feedback.pushInfo(self.tr(f"Usando função RBF: {rbf_function}"))
        if use_local:
            feedback.pushInfo(self.tr(f"Modo local - Máx vizinhos: {max_neighbors}, Raio: {search_radius}"))
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()
        x_min_grid = np.floor(x_min / cell_size) * cell_size
        y_min_grid = np.floor(y_min / cell_size) * cell_size
        x_max_grid = np.ceil(x_max / cell_size) * cell_size
        y_max_grid = np.ceil(y_max / cell_size) * cell_size
        num_cols = max(1, int(np.ceil((x_max_grid - x_min_grid) / cell_size)))
        num_rows = max(1, int(np.ceil((y_max_grid - y_min_grid) / cell_size)))
        grid_x = np.linspace(x_min_grid + cell_size / 2, x_max_grid - cell_size / 2, num_cols)
        grid_y = np.linspace(y_min_grid + cell_size / 2, y_max_grid - cell_size / 2, num_rows)
        feedback.pushInfo(self.tr(f"Dimensões do grid: {num_cols} x {num_rows} = {num_cols * num_rows} células"))
        interpolated_grid = interpolate_rbf_advanced(
            points_np, values_np, grid_x, grid_y,
            function=rbf_function, smooth=smooth_param,
            max_neighbors=max_neighbors, search_radius=search_radius,
            extrapolation_method=extrapolation_method,
            extrapolation_value=extrapolation_value,
            feedback=feedback
        )
        if interpolated_grid is None:
            raise QgsProcessingException(self.tr('Falha na interpolação RBF.'))
        feedback.setProgress(85)
        feedback.setProgressText(self.tr('Salvando raster...'))
        interpolated_grid_for_raster = np.flipud(interpolated_grid)
        output_crs = input_layer.sourceCrs()
        driver = gdal.GetDriverByName("GTiff")
        out_ds = driver.Create(
            output_raster_path, num_cols, num_rows, 1,
            gdal.GDT_Float32, ['COMPRESS=DEFLATE']
        )
        if out_ds is None:
            raise QgsProcessingException(self.tr(f'Falha ao criar arquivo raster: {output_raster_path}'))
        geotransform = (x_min_grid, cell_size, 0, y_max_grid, 0, -cell_size)
        out_ds.SetGeoTransform(geotransform)
        srs = osr.SpatialReference()
        srs.ImportFromWkt(output_crs.toWkt())
        out_ds.SetProjection(srs.ExportToWkt())
        out_band = out_ds.GetRasterBand(1)
        out_band.WriteArray(interpolated_grid_for_raster)
        out_band.SetDescription(f"RBF Interpolation - {rbf_function}")
        if extrapolation_method == 'none':
            out_band.SetNoDataValue(-9999)
            grid_with_nodata = np.where(np.isnan(interpolated_grid_for_raster), -9999, interpolated_grid_for_raster)
            out_band.WriteArray(grid_with_nodata)
        out_band.FlushCache()
        out_ds = None
        if os.path.exists(output_raster_path):
            raster_layer = QgsRasterLayer(output_raster_path, os.path.basename(output_raster_path))
            if raster_layer.isValid():
                QgsProject.instance().addMapLayer(raster_layer)
                feedback.pushInfo(self.tr(f"Raster adicionado ao mapa: {os.path.basename(output_raster_path)}"))
        feedback.setProgress(100)
        feedback.setProgressText(self.tr('Interpolação RBF avançada concluída!'))
        return {self.OUTPUT_RASTER: output_raster_path}

# Alias para compatibilidade
AdvancedRBFInterpolationAlgorithm = RbfInterpolationAdvancedAlgorithm
